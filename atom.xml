<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-26T07:42:41.496Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>jackey Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android之startActivityForResult问题</title>
    <link href="http://yoursite.com/2018/09/26/Android%E4%B9%8BstartActivityForResult%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/09/26/Android之startActivityForResult问题/</id>
    <published>2018-09-26T03:06:23.000Z</published>
    <updated>2018-09-26T07:42:41.496Z</updated>
    
    <content type="html"><![CDATA[<p>近期在写项目时，在使用startActivityForResult时遇到一些问题，虽然以前也有遇到过，由于时间比较久了，就忘记了。这次开始写博客，又恰逢遇到问题重现，就此写下短篇的记录短文。</p><p>先就现在比较常用的FragmengActivity的startActivityForResult源码进行解读：</p><p>先查看FragmengActivity的startActivityForResult源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Modifies the standard behavior to allow results to be delivered to fragments.</span></span><br><span class="line"><span class="comment"> * This imposes a restriction that requestCode be &lt;= 0xffff.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(Intent intent, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If this was started from a Fragment we've already checked the upper 16 bits were not in</span></span><br><span class="line">    <span class="comment">// use, and then repurposed them for the Fragment's index.</span></span><br><span class="line">    <span class="keyword">if</span> (!mStartedActivityFromFragment) &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestCode != -<span class="number">1</span>) &#123;</span><br><span class="line">            checkForValidRequestCode(requestCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.startActivityForResult(intent, requestCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过mStartedActivityFromFragment判断我们的startActivityForResult方法是否从Fragment发起的。如果不是，则需要对requestCode进行检验，至于这里为何要对requestCode检验，我们后面再解释。我们跟着方法进入FragmengtActivity中的父类方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(@RequiresPermission Intent intent, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            options = transferSpringboardActivityOptions(options);</span><br><span class="line">            Instrumentation.ActivityResult ar =</span><br><span class="line">                mInstrumentation.execStartActivity(</span><br><span class="line">                    <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                    intent, requestCode, options);</span><br><span class="line">            <span class="keyword">if</span> (ar != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mMainThread.sendActivityResult(</span><br><span class="line">                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                    ar.getResultData());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// If this start is requesting a result, we can avoid making</span></span><br><span class="line">                <span class="comment">// the activity visible until the result is received.  Setting</span></span><br><span class="line">                <span class="comment">// this code during onCreate(Bundle savedInstanceState) or onResume() will keep the</span></span><br><span class="line">                <span class="comment">// activity hidden during this time, to avoid flickering.</span></span><br><span class="line">                <span class="comment">// This can only be done when a result is requested because</span></span><br><span class="line">                <span class="comment">// that guarantees we will get information back when the</span></span><br><span class="line">                <span class="comment">// activity is finished, no matter what happens to it.</span></span><br><span class="line">                mStartedActivity = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cancelInputsAndStartExitTransition(options);</span><br><span class="line">            <span class="comment">// TODO Consider clearing/flushing other event sources and events for child windows.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode, options);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Note we want to go through this method for compatibility with</span></span><br><span class="line">                <span class="comment">// existing applications that may have overridden it.</span></span><br><span class="line">                mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>具体这里就不往下分析了，继续深入涉及ActivityManager以及ActivityThread的流程。有兴趣可自行查看。</p><p>这里说下我们经常遇到的一些问题，在一些APP上，我们需要用到startActivityForResult，来获取某个界面的数据。</p><p>现在Android大部分Activity开发基本都是使用FragmentActivity，内部嵌套多个Fragment。这时使用会遇到一些问题，如：</p><p>1、 在当前Fragment的onActivityResult的方法未调用，导致无法完成数据获取。</p><p>2、 在当前Activity中获取到的requestCode与发起的requestCode不一致。</p><p>等。</p><p>说下问题1：</p><p>当我们在Activity中或者Fragment中通过调用getActivity().startActivityForResult启动下一个activity时，当在activity setResult并调用finish时，回到调用的Activity我们去看下FragmentActivity的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Dispatch incoming result to the correct fragment.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">       mFragments.noteStateNotSaved();</span><br><span class="line">       <span class="keyword">int</span> requestIndex = requestCode&gt;&gt;<span class="number">16</span>;</span><br><span class="line">       <span class="keyword">if</span> (requestIndex != <span class="number">0</span>) &#123;</span><br><span class="line">           requestIndex--;</span><br><span class="line"></span><br><span class="line">           String who = mPendingFragmentActivityResults.get(requestIndex);</span><br><span class="line">           mPendingFragmentActivityResults.remove(requestIndex);</span><br><span class="line">           <span class="keyword">if</span> (who == <span class="keyword">null</span>) &#123;</span><br><span class="line">               Log.w(TAG, <span class="string">"Activity result delivered for unknown Fragment."</span>);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           Fragment targetFragment = mFragments.findFragmentByWho(who);</span><br><span class="line">           <span class="keyword">if</span> (targetFragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">               Log.w(TAG, <span class="string">"Activity result no fragment exists for who: "</span> + who);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               targetFragment.onActivityResult(requestCode &amp; <span class="number">0xffff</span>, resultCode, data);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ActivityCompat.PermissionCompatDelegate delegate =</span><br><span class="line">               ActivityCompat.getPermissionCompatDelegate();</span><br><span class="line">       <span class="keyword">if</span> (delegate != <span class="keyword">null</span> &amp;&amp; delegate.onActivityResult(<span class="keyword">this</span>, requestCode, resultCode, data)) &#123;</span><br><span class="line">           <span class="comment">// Delegate has handled the activity result</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在此方法中可以看到进入方法后，会对requestCode进行处理，使用过的都知道requestCode的值是有限制的。</p><p>此处对requestCode进行右移操作，最终获取的requestCode在正常范围内都是趋于零，导致不会进入条件内，也不会进入Fragment的onActivityResult，若此时需要对fragment的进行回调，则需要自己在代码自行添加。</p><p>问题2，进过排查，发现在通过调用fragment的startActivityForResult，在FragmentActivity处获取到的requestCode与发出的requestCode不一致，并且有点随机数，不过该随机数都很大。具体还没详细查阅源码。而且会进入Fragment的onActivityResult,并不会出现问题1的情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近期在写项目时，在使用startActivityForResult时遇到一些问题，虽然以前也有遇到过，由于时间比较久了，就忘记了。这次开始写博客，又恰逢遇到问题重现，就此写下短篇的记录短文。&lt;/p&gt;
&lt;p&gt;先就现在比较常用的FragmengActivity的startAct
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="startActivityForResult" scheme="http://yoursite.com/tags/startActivityForResult/"/>
    
  </entry>
  
  <entry>
    <title>Android面试大全</title>
    <link href="http://yoursite.com/2018/09/25/Android%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8/"/>
    <id>http://yoursite.com/2018/09/25/Android面试大全/</id>
    <published>2018-09-25T10:58:44.000Z</published>
    <updated>2018-09-25T11:01:04.728Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要整理下Android的面试知识点：</p><ol><li><p>多线程下载。</p></li><li><p>string,stringbuffer,stringbuilder区别。<br>1&gt;.首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String<br>2&gt;.在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的<br>String：适用于少量的字符串操作的情况<br>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况<br>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p></li><li><p>性能优化（内存，ui,网络，图片缓存）。</p></li><li><p>mvp架构(画个简单图) </p></li><li><p>框架(网络，图片，view注入，数据库)基本使用和原理。</p></li><li><p>最好读过源码</p></li></ol><ol start="7"><li>view绘制流程。</li></ol><ol start="8"><li>事件传递过程。</li></ol><ol start="9"><li>handler机制。</li></ol><ol start="10"><li><p>多线程安全。</p></li><li><p>关键字。</p></li><li><p>内存泄露。 </p></li><li><p>有两个集合ab  量级为几万条数据，a为新数据，b为老数据    怎么将a最快速度更新到b去最快速度<br>数据集合比较大的情况下，使用HashSet替代ArrayList，使用contrains方法。</p></li><li><p>布局中一个view设置隐藏了，页面是怎么更新的，详细谈谈这个</p></li><li><p>安卓的gc模型   </p></li><li><p>如何加载超大图片  且不能压缩      然后怎么读取的  怎么转的   滑动时怎么处理的</p></li><li><p>有哪几种锁机制  区别在哪儿 </p></li><li><p>hashmap实现原理   </p></li><li><p>https原理   </p></li><li><p>aidl，binder原理   </p></li><li><p>linux进程间通信方式   </p></li></ol><ol start="22"><li>热修复，插件化的实现原理    </li></ol><p>23.类加载原理：<br>​    1)双亲委托模式</p><pre><code>PathClassLoader：只能加载已经安装到Android系统中的apk文件（/data/app目录），是Android默认使用的类加载器。DexClassLoader：可以加载任意目录下的dex/jar/apk/zip文件，也就是我们一开始提到的补丁。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇主要整理下Android的面试知识点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;多线程下载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;string,stringbuffer,stringbuilder区别。&lt;br&gt;1&amp;gt;.首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android优化之内存篇</title>
    <link href="http://yoursite.com/2018/09/24/Android%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E7%AF%87/"/>
    <id>http://yoursite.com/2018/09/24/Android优化之内存篇/</id>
    <published>2018-09-24T04:10:26.000Z</published>
    <updated>2018-09-25T14:56:14.777Z</updated>
    
    <content type="html"><![CDATA[<p>本文来自于<strong>腾讯Bugly</strong>公众号（<strong>weixinBugly</strong>）,原文地址：<a href="https://mp.weixin.qq.com/s/2MsEAR9pQfMr1Sfs7cPdWQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2MsEAR9pQfMr1Sfs7cPdWQ</a></p><hr><p>工欲善其事必先利其器，想要优化App的内存占用，那么还是需要先了解Android系统的内存分配和回收机制。</p><h2 id="一、Android内存分配回收机制"><a href="#一、Android内存分配回收机制" class="headerlink" title="一、Android内存分配回收机制"></a>一、Android内存分配回收机制</h2><p>从宏观角度上来看Android系统可以分为三个层次</p><ol><li>Application Framework,</li><li>Dalvik 虚拟机</li><li>Linux内核。</li></ol><p>这三个层次都有各自内存相关工作：</p><h4 id="1-Application-Framework"><a href="#1-Application-Framework" class="headerlink" title="1. Application Framework"></a>1. Application Framework</h4><p>Anroid基于进程中运行的组件及其状态规定了默认的五个回收优先级：</p><ul><li>Empty process(空进程)</li><li>Background process(后台进程)</li><li>Service process(服务进程)</li><li>Visible process(可见进程)</li><li>Foreground process(前台进程)</li></ul><p>系统需要进行内存回收时最先回收空进程,然后是后台进程，以此类推最后才会回收前台进程（一般情况下前台进程就是与用户交互的进程了,如果连前台进程都需要回收那么此时系统几乎不可用了）。</p><p>由此也衍生了很多进程保活的方法（提高优先级，互相唤醒，native保活等等），出现了国内各种全家桶，甚至各种杀不死的进程。</p><p>Android中由ActivityManagerService 集中管理所有进程的内存资源分配。</p><h4 id="2-Linux内核"><a href="#2-Linux内核" class="headerlink" title="2. Linux内核"></a>2. Linux内核</h4><h4 id="3-Dalvik虚拟机"><a href="#3-Dalvik虚拟机" class="headerlink" title="3. Dalvik虚拟机"></a>3. Dalvik虚拟机</h4><p>Android中有Native Heap和Dalvik Heap。Android的Native Heap言理论上可分配的空间取决了硬件RAM，而对于每个进程的Dalvik Heap都是有大小限制的，具体策略可以看看android dalvik heap 浅析[4]。</p><p><strong>Android App为什么会OOM呢？</strong>其实就是申请的内存超过了Dalvik Heap的最大值。这里也诞生了一些比较”黑科技”的内存优化方案，比如将耗内存的操作放到Native层，或者使用分进程的方式突破每个进程的Dalvik Heap内存限制。</p><p>Android Dalvik Heap与原生Java一样，将堆的内存空间分为三个区域，Young Generation，Old Generation， Permanent Generation。</p><p>最近分配的对象会存放在Young Generation区域，当这个对象在这个区域停留的时间达到一定程度，它会被移动到Old Generation，最后累积一定时间再移动到Permanent Generation区域。系统会根据内存中不同的内存数据类型分别执行不同的gc操作。</p><p>GC发生的时候，所有的线程都是会被暂停的。执行GC所占用的时间和它发生在哪一个Generation也有关系，Young Generation中的每次GC操作时间是最短的，Old Generation其次，Permanent Generation最长。</p><p>GC时会导致线程暂停，导致卡顿，Google在新版本的Android中优化了这个问题， 在ART中对GC过程做了优化揭秘 ART 细节 —— Garbage collection[5]，据说内存分配的效率提高了10倍，GC的效率提高了2-3倍（可见原来效率有多低），不过主要还是优化中断和阻塞的时间，频繁的GC还是会导致卡顿。</p><p>上面就是Android系统内存分配和回收相关知识，回过头来看，现在各种手机厂商鼓吹人工智能手机，号称18个月不卡顿，越用越快，其实很大一部分Android系统的内存优化有关，无非就是利用一些比较成熟的基于统计，机器学习的算法定时清理数据，清理内存，甚至提前加载数据到内存。</p><h2 id="二、Android常见内存问题和对应检测，解决方式"><a href="#二、Android常见内存问题和对应检测，解决方式" class="headerlink" title="二、Android常见内存问题和对应检测，解决方式"></a>二、Android常见内存问题和对应检测，解决方式</h2><h4 id="1-内存泄露"><a href="#1-内存泄露" class="headerlink" title="1. 内存泄露"></a>1. 内存泄露</h4><p>不止Android程序员，内存泄露应该是大部分程序员都遇到过的问题，可以说大部分的内存问题都是内存泄露导致的，Android里也有一些很常见的内存泄露问题[6]，这里简单罗列下：</p><ul><li><strong>单例</strong>（主要原因还是因为一般情况下单例都是全局的，有时候会引用一些实际生命周期比较短的变量，导致其无法释放）</li><li><strong>静态变量</strong>（同样也是因为生命周期比较长）</li><li><strong>Handler内存泄露</strong>[7]</li><li><strong>匿名内部类</strong>（匿名内部类会引用外部类，导致无法释放，比如各种回调）</li><li><strong>资源使用完未关闭</strong>（BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap）</li></ul><p>对Android内存泄露业界已经有很多优秀的组件其中LeakCanary最为知名(Square出品，Square可谓Android开源界中的业界良心，开源的项目包括okhttp, retrofit，otto, picasso, Android开发大神Jake Wharton就在Square)，其原理是监控每个activity，在activity ondestory后，在后台线程检测引用，然后过一段时间进行gc，gc后如果引用还在，那么dump出内存堆栈，并解析进行可视化显示。使用LeakCanary可以快速地检测出Android中的内存泄露。</p><p>正常情况下，解决大部分内存泄露问题后，App稳定性应该会有很大提升，但是有时候App本身就是有一些比较耗内存的功能，比如直播，视频播放，音乐播放，那么我们还有什么能做的可以降低内存使用，减少OOM呢？</p><h4 id="2-图片分辨率相关"><a href="#2-图片分辨率相关" class="headerlink" title="2. 图片分辨率相关"></a>2. 图片分辨率相关</h4><p><strong>分辨率适配问题</strong>。很多情况下图片所占的内存在整个App内存占用中会占大部分。我们知道可以通过将图片放到hdpi/xhdpi/xxhdpi等不同文件夹进行适配，通过xml android:background设置背景图片，或者通过BitmapFactory.decodeResource()方法，图片实际上默认情况下是会进行缩放的。在Java层实际调用的函数都是或者通过BitmapFactory里的decodeResourceStream函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeResourceStream</span><span class="params">(Resources res, TypedValue value,</span></span></span><br><span class="line"><span class="function"><span class="params">        InputStream is, Rect pad, Options opts)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opts == <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        opts = <span class="keyword">new</span> Options();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opts.inDensity == <span class="number">0</span> &amp;&amp; value != <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> density = value.density;</span><br><span class="line">       <span class="keyword">if</span> (density == TypedValue.DENSITY_DEFAULT)</span><br><span class="line">       &#123;</span><br><span class="line">           opts.inDensity = DisplayMetrics.DENSITY_DEFAULT;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (density != TypedValue.DENSITY_NONE)</span><br><span class="line">       &#123;</span><br><span class="line">           opts.inDensity = density;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span> (opts.inTargetDensity == <span class="number">0</span> &amp;&amp; res != <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        opts.inTargetDensity = res.getDisplayMetrics().densityDpi;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> decodeStream(is, pad, opts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>decodeResource在解析时会对Bitmap根据当前设备屏幕像素密度densityDpi的值进行缩放适配操作，使得解析出来的Bitmap与当前设备的分辨率匹配，达到一个最佳的显示效果，并且Bitmap的大小将比原始的大，可以参考下腾讯Bugly的详细分析Android 开发绕不过的坑：<a href="http://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=403263974&amp;idx=1&amp;sn=b0315addbc47f3c38e65d9c633a12cd6&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">你的 Bitmap 究竟占多大内存？</a></p><p>关于Density、分辨率、-hdpi等res目录之间的关系：</p><p><img src="/Users/apple/Pictures/博客截图/643.png" alt="643"></p><blockquote><p>举个例子，对于一张1280×720的图片，如果放在xhdpi，那么xhdpi的设备拿到的大小还是1280×720而xxhpi的设备拿到的可能是1920×1080，这两种情况在内存里的大小分别为：3.68M和8.29M，相差4.61M，在移动设备来说这几M的差距还是很大的。</p></blockquote><p>尽管现在已经有比较先进的图片加载组件类似Glide，Facebook Freso, 或者老牌Universal-Image-Loader，但是有时就是需要手动拿到一个bitmap或者drawable，特别是在一些可能会频繁调用的场景(比如ListView的getView)，怎样尽可能对bitmap进行复用呢？这里首先需要明确的是对同样的图片，要 尽可能复用，我们可以简单自己用WeakReference做一个bitmap缓存池，也可以用类似图片加载库写一个通用的bitmap缓存池，可以参考GlideBitmapPool[8]的实现。</p><p>我们也来看看系统是怎么做的，对于类似在xml里面直接通过android:background或者android:src设置的背景图片，以ImageView为例，最终会调用Resource.java里的loadDrawable:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Drawable <span class="title">loadDrawable</span><span class="params">(TypedValue value, <span class="keyword">int</span> id, Theme theme)</span> <span class="keyword">throws</span> NotFoundException </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Next, check preloaded drawables. These may contain unresolved theme</span></span><br><span class="line">    <span class="comment">// attributes.</span></span><br><span class="line">    <span class="keyword">final</span> ConstantState cs;</span><br><span class="line">    <span class="keyword">if</span> (isColorDrawable)</span><br><span class="line">    &#123;</span><br><span class="line">        cs = sPreloadedColorDrawables.get(key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Drawable dr;</span><br><span class="line">    <span class="keyword">if</span> (cs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dr = cs.newDrawable(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isColorDrawable) &#123;</span><br><span class="line">        dr = <span class="keyword">new</span> ColorDrawable(value.data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dr = loadDrawableForCookie(value, id, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到实际上系统也是有一份全局的缓存，sPreloadedDrawables, 对于不同的drawable，如果图片时一样的，那么最终只会有一份bitmap(享元模式)，存放于BitmapState中，获取drawable时，系统会从缓存中取出这个bitmap然后构造drawable。而通过BitmapFactory.decodeResource()则每次都会重新解码返回bitmap。所以其实我们可以通过context.getResources().getDrawable再从drawable里获取bitmap，从而复用bitmap，然而这里也有一些坑，比如我们获取到的这份bitmap，假如我们执行了recycle之类的操作，但是假如在其他地方再使用它是那么就会有”Canvas: trying to use a recycled bitmap android.graphics.Bitmap”异常。</p><h4 id="3-图片压缩"><a href="#3-图片压缩" class="headerlink" title="3. 图片压缩"></a>3. 图片压缩</h4><p>BitmapFactory 在解码图片时，可以带一个Options，有一些比较有用的功能，比如：</p><ul><li><strong>inTargetDensity</strong> 表示要被画出来时的目标像素密度</li><li><strong>inSampleSize</strong> 这个值是一个int，当它小于1的时候，将会被当做1处理，如果大于1，那么就会按照比例（1 / inSampleSize）缩小bitmap的宽和高、降低分辨率，大于1时这个值将会被处置为2的倍数。例如，width=100，height=100，inSampleSize=2，那么就会将bitmap处理为，width=50，height=50，宽高降为1 / 2，像素数降为1 / 4</li><li><strong>inJustDecodeBounds</strong> 字面意思就可以理解就是只解析图片的边界，有时如果只是为了获取图片的大小就可以用这个，而不必直接加载整张图片。</li><li><strong>inPreferredConfig</strong> 默认会使用ARGB_8888,在这个模式下一个像素点将会占用4个byte,而对一些没有透明度要求或者图片质量要求不高的图片，可以使用RGB_565，一个像素只会占用2个byte，一下可以省下50%内存。</li><li><strong>inPurgeable</strong>和<strong>inInputShareable</strong> 这两个需要一起使用，BitmapFactory.java的源码里面有注释，大致意思是表示在系统内存不足时是否可以回收这个bitmap，有点类似软引用，但是实际在5.0以后这两个属性已经被忽略，因为系统认为回收后再解码实际会反而可能导致性能问题</li><li><strong>inBitmap</strong> 官方推荐使用的参数，表示重复利用图片内存，减少内存分配，在4.4以前只有相同大小的图片内存区域可以复用，4.4以后只要原有的图片比将要解码的图片大既可以复用了。</li></ul><h4 id="4-缓存池大小"><a href="#4-缓存池大小" class="headerlink" title="4. 缓存池大小"></a>4. 缓存池大小</h4><p>现在很多图片加载组件都不仅仅是使用软引用或者弱引用了，实际上类似Glide 默认使用的事LruCache，因为软引用 弱引用都比较难以控制，使用LruCache可以实现比较精细的控制，而默认缓存池设置太大了会导致浪费内存，设置小了又会导致图片经常被回收，所以需要根据每个App的情况，以及设备的分辨率，内存计算出一个比较合理的初始值，可以参考Glide的做法。</p><h4 id="5-内存抖动"><a href="#5-内存抖动" class="headerlink" title="5. 内存抖动"></a>5. 内存抖动</h4><p>什么是内存抖动呢？Android里内存抖动是指内存频繁地分配和回收，而频繁的gc会导致卡顿，严重时还会导致OOM。</p><p>一个很经典的案例是string拼接创建大量小的对象(比如在一些频繁调用的地方打字符串拼接的log的时候), 见Android优化之String篇[9]。</p><p><strong>而内存抖动为什么会引起OOM呢？</strong></p><p>主要原因还是有因为大量小的对象频繁创建，导致内存碎片，从而当需要分配内存时，虽然总体上还是有剩余内存可分配，而由于这些内存不连续，导致无法分配，系统直接就返回OOM了。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><strong>常用数据结构优化</strong>，ArrayMap及SparseArray是android的系统API，是专门为移动设备而定制的。用于在一定情况下取代HashMap而达到节省内存的目的,具体性能见HashMap，ArrayMap，SparseArray源码分析及性能对比[10]，对于key为int的HashMap尽量使用SparceArray替代，大概可以省30%的内存，而对于其他类型，ArrayMap对内存的节省实际并不明显，10%左右，但是数据量在1000以上时，查找速度可能会变慢。</p><p><strong>枚举</strong>，Android平台上枚举是比较争议的，在较早的Android版本，使用枚举会导致包过大，在个例子里面，使用枚举甚至比直接使用int包的size大了10多倍 在stackoverflow上也有很多的讨论, 大致意思是随着虚拟机的优化，目前枚举变量在Android平台性能问题已经不大，而目前Android官方建议，使用枚举变量还是需要谨慎，因为枚举变量可能比直接用int多使用2倍的内存。</p><p><strong>ListView复用</strong>，这个大家都知道，getView里尽量复用conertView,同时因为getView会频繁调用，要避免频繁地生成对象</p><p><strong>谨慎使用多进程</strong>，现在很多App都不是单进程，为了保活，或者提高稳定性都会进行一些进程拆分，而实际上即使是空进程也会占用内存(1M左右)，对于使用完的进程，服务都要及时进行回收。</p><p><strong>尽量使用系统资源</strong>，系统组件，图片甚至控件的id</p><p><strong>减少view的层级</strong>，对于可以 延迟初始化的页面，使用viewstub</p><p><strong>数据相关</strong>：序列化数据使用protobuf可以比xml省30%内存，慎用shareprefercnce，因为对于同一个sp，会将整个xml文件载入内存，有时候为了读一个配置，就会将几百k的数据读进内存，数据库字段尽量精简，只读取所需字段。</p><p><strong>dex优化，代码优化，谨慎使用外部库</strong>， 有人觉得代码多少于内存没有关系，实际会有那么点关系，现在稍微大一点的项目动辄就是百万行代码以上，多dex也是常态，不仅占用rom空间，实际上运行的时候需要加载dex也是会占用内存的(几M)，有时候为了使用一些库里的某个功能函数就引入了整个庞大的库，此时可以考虑抽取必要部分，开启proguard优化代码，使用Facebook redex使用优化dex(好像有不少坑)。</p><h4 id="文中引用参考链接"><a href="#文中引用参考链接" class="headerlink" title="文中引用参考链接"></a>文中引用参考链接</h4><blockquote><p>1.Android 操作系统的内存回收机制<br><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-android-mmry-rcycl/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-cn-android-mmry-rcycl/</a></p><p>2.阿里巴巴的Android内存优化分享<br><a href="http://www.infoq.com/cn/presentations/android-memory-optimization" target="_blank" rel="noopener">http://www.infoq.com/cn/presentations/android-memory-optimization</a></p><p>3.Android进程的内存管理分析<br><a href="http://blog.csdn.net/gemmem/article/details/8920039" target="_blank" rel="noopener">http://blog.csdn.net/gemmem/article/details/8920039</a></p><p>4.android dalvik heap 浅析<br><a href="http://blog.csdn.net/cqupt_chen/article/details/11068129" target="_blank" rel="noopener">http://blog.csdn.net/cqupt_chen/article/details/11068129</a></p><p>5.揭秘 ART 细节 —— Garbage collection<br><a href="http://www.cnblogs.com/jinkeep/p/3818180.html" target="_blank" rel="noopener">http://www.cnblogs.com/jinkeep/p/3818180.html</a></p><p>6.Android性能优化之常见的内存泄漏<br><a href="http://blog.csdn.net/u010687392/article/details/49909477" target="_blank" rel="noopener">http://blog.csdn.net/u010687392/article/details/49909477</a></p><p>7.Android App 内存泄露之Handler<br><a href="http://blog.csdn.net/zhuanglonghai/article/details/38233069" target="_blank" rel="noopener">http://blog.csdn.net/zhuanglonghai/article/details/38233069</a></p><p>8.GlideBitmapPool<br><a href="https://github.com/amitshekhariitbhu/GlideBitmapPool" target="_blank" rel="noopener">https://github.com/amitshekhariitbhu/GlideBitmapPool</a></p><p>9.Android 性能优化之String篇<br><a href="http://blog.csdn.net/vfush/article/details/53038437" target="_blank" rel="noopener">http://blog.csdn.net/vfush/article/details/53038437</a></p><p>10.HashMap，ArrayMap，SparseArray源码分析及性能对比<br><a href="http://www.jianshu.com/p/7b9a1b386265" target="_blank" rel="noopener">http://www.jianshu.com/p/7b9a1b386265</a></p><p>11.MAT使用教程<br><a href="http://blog.csdn.net/itomge/article/details/48719527" target="_blank" rel="noopener">http://blog.csdn.net/itomge/article/details/48719527</a></p><p>12.MAT - Memory Analyzer Tool 使用进阶<br><a href="http://www.lightskystreet.com/2015/09/01/mat_usage/" target="_blank" rel="noopener">http://www.lightskystreet.com/2015/09/01/mat_usage/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文来自于&lt;strong&gt;腾讯Bugly&lt;/strong&gt;公众号（&lt;strong&gt;weixinBugly&lt;/strong&gt;）,原文地址：&lt;a href=&quot;https://mp.weixin.qq.com/s/2MsEAR9pQfMr1Sfs7cPdWQ&quot; target=&quot;_
      
    
    </summary>
    
    
      <category term="内存优化" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android基础UI篇</title>
    <link href="http://yoursite.com/2018/09/24/Android%E4%BC%98%E5%8C%96%E4%B9%8BUI%E7%AF%87/"/>
    <id>http://yoursite.com/2018/09/24/Android优化之UI篇/</id>
    <published>2018-09-24T04:09:42.000Z</published>
    <updated>2018-09-25T10:59:46.029Z</updated>
    
    <content type="html"><![CDATA[<p>在Android开发中，由于Android碎片化严重，屏幕分辨率千奇百怪，而想要在各种分辨率的设备上显示基本一致的效果，<br>适配成本越来越高。虽然Android官方提供了dp单位来适配，但其在各种奇怪分辨率下表现却不尽如人意，因此下面探索<br>一种简单且低侵入的适配方式。</p><p><strong>官方术语：</strong></p><p><strong><em>屏幕密度</em></strong></p><p>屏幕物理区域中的像素量；通常称为 dpi（每英寸 点数）。例如， 与“正常”或“高”密度屏幕相比，“低”密度屏幕在给定物理区域的像素较少。为简便起见，Android 将所有屏幕密度分组为六种通用密度： 低、中、高、超高、超超高和超超超高。</p><p><em>方向</em></p><p>从用户视角看屏幕的方向，即横屏还是 竖屏，分别表示屏幕的纵横比是宽还是高。请注意， 不仅不同的设备默认以不同的方向操作，而且 方向在运行时可随着用户旋转设备而改变。</p><p><strong><em>分辨率</em></strong></p><p>屏幕上物理像素的总数。添加对多种屏幕的支持时， 应用不会直接使用分辨率；而只应关注通用尺寸和密度组指定的屏幕 尺寸及密度。</p><p><strong><em>密度无关像素 (dp)</em></strong></p><p>在定义 UI 布局时应使用的虚拟像素单位，用于以密度无关方式表示布局维度 或位置。</p><p>密度无关像素等于 160 dpi 屏幕上的一个物理像素，这是 系统为“中”密度屏幕假设的基线密度。在运行时，系统 根据使用中屏幕的实际密度按需要以透明方式处理 dp 单位的任何缩放 。dp 单位转换为屏幕像素很简单：<code>px = dp * (dpi / 160)</code>。 例如，在 240 dpi 屏幕上，1 dp 等于 1.5 物理像素。在定义应用的 UI 时应始终使用 dp 单位 ，以确保在不同密度的屏幕上正常显示 UI。</p><p>六种通用的</p><p>密度：</p><ul><li><em>ldpi</em>（低）~120dpi</li><li><em>mdpi</em>（中）~160dpi</li><li><em>hdpi</em>（高）~240dpi</li><li><em>xhdpi</em>（超高）~320dpi</li><li><em>xxhdpi</em>（超超高）~480dpi</li><li><em>xxxhdpi</em>（超超超高）~640dpi</li></ul><h3 id="官方推荐适配策略："><a href="#官方推荐适配策略：" class="headerlink" title="官方推荐适配策略："></a>官方推荐适配策略：</h3><ol><li>在 XML 布局文件中指定尺寸时使用 <code>wrap_content</code>、<code>match_parent</code> 或 <code>dp</code> 单位 。</li><li>不要在应用代码中使用硬编码的像素值</li><li>不要使用 <code>AbsoluteLayout</code>（已弃用）</li><li>为不同屏幕密度提供替代位图可绘制对象</li></ol><h3 id="UI适配策略"><a href="#UI适配策略" class="headerlink" title="UI适配策略"></a>UI适配策略</h3><p>1、 今日头条适配方案：<br>通过修改系统DisplayMetrics中的density的值来实现适配,以下为设计图为宽为360dp的适配代码<br>摘自<a href="https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA" target="_blank" rel="noopener">今日头条技术博客</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> aNoncompatDensity;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> aNoncompatScaledDensity;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCustomDensity</span><span class="params">(Activity activity,<span class="keyword">final</span> Application applicaiton)</span></span>&#123;</span><br><span class="line"><span class="keyword">final</span> DisplayMetrics appDisplayMetircs = appilcation.getResources.getDisplayMetrics();</span><br><span class="line"><span class="keyword">if</span>(aNoncompatDensity ==<span class="number">0</span>)&#123;</span><br><span class="line">aNoncompatDensity = appDisplayMetircs.density;</span><br><span class="line">aNoncompatScaledDensity = appDisplayMetircs.scaleDensity;</span><br><span class="line">applicaiton.registComponentCallbacks(<span class="keyword">new</span> ComponentCallbacks()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(newConfig !=<span class="keyword">null</span> &amp;&amp; newConfig.fontScale &gt;<span class="number">0</span>)&#123;</span><br><span class="line">aNoncompatScaledDensity =  application.getResources().getDisplayMetrics().scaleDensity;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLowMemory</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> targetDensity =  appDisplayMetircs.widthPixels /<span class="number">360</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> targetScaledDensity = targetDensity * (aNoncompatScaledDensity/aNoncompatDensity);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> targetDensityDpi = (<span class="keyword">int</span>) (<span class="number">160</span>*targetDensity);</span><br><span class="line">appDisplayMetircs.density = targetDensity;</span><br><span class="line">appDisplayMetircs.scaledDensity = targetScaledDensity;</span><br><span class="line">appDisplayMetircs.densityDpi = targetDensityDpi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> DisplayMetrics activityDisplayMetrics = activity.getResources().getDisplayMetrics();</span><br><span class="line">activityDisplayMetrics.density = targetDensity;</span><br><span class="line">activityDisplayMetrics.scaledDensity = targetScaledDensity;</span><br><span class="line">activityDisplayMetrics.densityDpi = targetDensityDpi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、  使用最小宽度限定符 如sw-360dp的方式去实现适配。</p><h3 id="Android-UI优化建议"><a href="#Android-UI优化建议" class="headerlink" title="Android UI优化建议"></a>Android UI优化建议</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1.1布局优化</span><br><span class="line">a&gt;: 避免复杂的View层级。布局越复杂就越臃肿，就越容易出现性能问题，寻找最节省资源的方式去展示嵌套的内容；</span><br><span class="line">        b&gt;: 尽量避免在视图层级的顶层使用相对布局 RelativeLayout 。相对布局 RelativeLayout 比较耗资源，因为一个相对布局 RelativeLayout 需要两次度量来确保自己处理了所有的布局关系，而且这个问题会伴随着视图层级中的相对布局 RelativeLayout 的增多，而变得更严重；</span><br><span class="line">        c&gt;: 布局层级一样的情况建议使用线性布局 LinearLayout 代替相对布局 RelativeLayout*，因为线性布局 LinearLayout 性能要更高一些；确实需要对分支进行相对布局 RelativeLayout 的时候，可以考虑更优化的网格布局 GridLayout ，它已经预处理了分支视图的关系，可以避免两次度量的问题；</span><br><span class="line">        d&gt;:相对复杂的布局建议采用相对布局 RelativeLayout ，相对布局 RelativeLayout 可以简单实现线性布局 LinearLayout 嵌套才能实现的布局；</span><br><span class="line">        e&gt;:不要使用绝对布局 AbsoluteLayout ；</span><br><span class="line">        f&gt;:将可重复使用的组件抽取出来并用 &lt;/include&gt; 标签进行重用。如果应用多个地方的 UI 用到某个布局，就将其写成一个布局部件，便于各个 UI 重用。官方详解 「 戳我 」</span><br><span class="line">        g&gt;:使用 merge 标签减少布局的嵌套层次，官方详解 「 戳我 」；</span><br><span class="line">        h&gt;:去掉多余的不可见背景。有多层背景颜色的布局，只留最上层的对用户可见的颜色即可，其他用户不可见的底层颜色可以去掉，减少无效的绘制操作；</span><br><span class="line">        i&gt;:尽量避免使用 layout_weight 属性。使用包含 layout_weight 属性的线性布局 LinearLayout 每一个子组件都需要被测量两次，会消耗过多的系统资源。在使用 ListView 标签与 GridView 标签的时候，这个问题显的尤其重要，因为子组件会重复被创建。平分布局可以使用相对布局 RelativeLayout 里一个 0dp 的 view 做分割线来搞定，如果不行，那就……；</span><br><span class="line">        j&gt;:合理的界面的布局结构应是宽而浅，而不是窄而深；</span><br><span class="line"></span><br><span class="line">    1.2 优化逻辑处理</span><br><span class="line">    a&gt;:按需载入视图。某些不怎么重用的耗资源视图，可以等到需要的时候再加载，提高UI渲染速度；</span><br><span class="line">        b&gt;:使用 ViewStub 标签来加载一些不常用的布局；</span><br><span class="line">c&gt;:动态地 inflation view 性能要比用 ViewStub 标签的 setVisiblity 性能要好，当然某些功能的实现采用 ViewStub 标签更合适；</span><br><span class="line">d&gt;:尽量避免不必要的耗资源操作，节省宝贵的运算时间；</span><br><span class="line">e&gt;:避免在 UI 线程进行繁重的操作。耗资源的操作（比如 IO 操作、网络操作、SQL 操作、列表刷新等）耗资源的操作应用后台进程去实现，不能占用 UI 线程，UI 线程是主线程，主线程是保持程序流畅的关键，应该只操作那些核心的 UI 操作，比如处理视图的属性和绘制；</span><br><span class="line">f&gt;:最小化唤醒机制。我们常用广播来接收那些期望响应的消息和事件，但过多的响应超过本身需求的话，会消耗多余的 Android 设备性能和资源。所以应该最小化唤醒机制，当应用不关心这些消失和事件时，就关闭广播，并慎重选择那些要响应的 Intent 。</span><br><span class="line">h&gt;:为低端设备考虑，比如 512M 内存、双核 CPU 、低分辨率，确保你的应用可以满足不同水平的设备。</span><br><span class="line">i&gt;:优化应用的启动速度。当应用启动一个应用时，界面的尽快反馈显示可以给用户一个良好的体验。为了启动更快，可以延迟加载一些 UI 以及避免在应用 Application 层级初始化代码。</span><br><span class="line"></span><br><span class="line">1.3 优化工具</span><br><span class="line"></span><br><span class="line">另外有些强大但可能少用的工具在测试性能渲染时辅助分析，比如：</span><br><span class="line">1):HierarchyViewer：这个工具常用来查看界面的视图结构是否过于复杂，用于了解哪些视图过度绘制，又该如何进行改进；</span><br><span class="line">2):Tracer for OpenGL：这个工具收集了所有UI界面发给GPU的绘制命令。常用于辅助开发人员 DEBUG 、定位一些 HierarchyViewer 工具定位不了的疑难渲染细节问题。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Android开发中，由于Android碎片化严重，屏幕分辨率千奇百怪，而想要在各种分辨率的设备上显示基本一致的效果，&lt;br&gt;适配成本越来越高。虽然Android官方提供了dp单位来适配，但其在各种奇怪分辨率下表现却不尽如人意，因此下面探索&lt;br&gt;一种简单且低侵入的适配方
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java程序排查问题利器之Btrace</title>
    <link href="http://yoursite.com/2018/09/24/Java%E7%A8%8B%E5%BA%8F%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98%E5%88%A9%E5%99%A8%E4%B9%8BBtrace/"/>
    <id>http://yoursite.com/2018/09/24/Java程序排查问题利器之Btrace/</id>
    <published>2018-09-24T01:54:36.000Z</published>
    <updated>2018-09-24T02:33:53.591Z</updated>
    
    <content type="html"><![CDATA[<p>Java程序排查问题利器之Btrace</p><h4 id="（一）Btrace的介绍"><a href="#（一）Btrace的介绍" class="headerlink" title="（一）Btrace的介绍"></a>（一）Btrace的介绍</h4><p>BTrace是Java的安全可靠的动态跟踪工具。 他的工作原理是通过 instrument + asm 来对正在运行的java程序中的class类进行动态增强，可以在不用重启的情况下监控系统运行情况，方便的获取程序运行时的数据信息，如方法参数、返回值、全局变量和堆栈信息等，并且做到最少的侵入，占用最少的系统资源。</p><p>正如上面描述的一些特性，所以btrace一般是用来排查生产环境jvm问题的一款利器，使用它不用再担心应用程序的日志打的不够全，不够细，也不用为了排查问题一遍遍的重启程序。</p><h4 id="（二）Btrace的一些限制"><a href="#（二）Btrace的一些限制" class="headerlink" title="（二）Btrace的一些限制"></a>（二）Btrace的一些限制</h4><pre><code>由于Btrace会把脚本逻辑直接侵入到运行的代码中，所以在使用上做很多限制：    1、不能创建对象    2、不能使用数组    3、不能抛出或捕获异常    4、不能使用循环    5、不能使用synchronized关键字    6、属性和方法必须使用static修饰</code></pre><p>此外不恰当的使用BTrace可能导致生产程序直接挂掉，所以在上生产环境之前，务必在开发环境充分验证脚本的正确性。</p><h4 id="（三）Btrace能干什么"><a href="#（三）Btrace能干什么" class="headerlink" title="（三）Btrace能干什么"></a>（三）Btrace能干什么</h4><pre><code>（1）分析任意接口或者方法的耗时情况（2）分析不断的添加数据时，Map的扩容情况（3）分析那个方法里面调用了System.gc()方法，并打印出其调用栈（4）某些方法抛出异常时，分析其运行参数（5）统计一些接口的调用次数（6）分析一些方法的代码是否执行到了某一行（7）..........</code></pre><p>注意上面的所有操作，都是监控正在运行中的程序，基本不会产生任何影响。</p><h4 id="（四）Btrace的安装"><a href="#（四）Btrace的安装" class="headerlink" title="（四）Btrace的安装"></a>（四）Btrace的安装</h4><p>（1）从github上下载最新的二进制包 ，版本是1.3.10.2</p><pre><code>wget https://github.com/btraceio/btrace/releases/download/v1.3.10.2/btrace-bin-1.3.10.2.tgz</code></pre><p>（2）解压到指定路径</p><p>（3）设置环境变量</p><pre><code>BTRACE_HOME=/root/btraceexport BTRACE_HOMEexport PATH=$PATH:$BTRACE_HOME/bin</code></pre><p>（4）验证安装是否成功</p><pre><code> [root@es1 ~]# btrace --versionBTrace v.1.3.10 (20171121)</code></pre><p>（5）查看btrace的帮助文档</p><pre><code>[root@es1 build]# btraceUsage: btrace &lt;options&gt; &lt;pid&gt; &lt;btrace source or .class file&gt; &lt;btrace arguments&gt;where possible options include: --version             Show the version  -v                    Run in verbose mode  -o &lt;file&gt;             The path to store the probe output (will disable showing the output in console)-u                    Run in trusted mode  -d &lt;path&gt;             Dump the instrumented classes to the specified path  -pd &lt;path&gt;            The search path for the probe XML descriptors  -classpath &lt;path&gt;     Specify where to find user class files and annotation processors  -cp &lt;path&gt;            Specify where to find user class files and annotation processors  -I &lt;path&gt;             Specify where to find include files  -p &lt;port&gt;             Specify port to which the btrace agent listens for clients  -statsd &lt;host[:port]&gt; Specify the statsd server, if any</code></pre><p>（五）Btrace使用的一个例子</p><p>注意btrace在maven上发布的jar，版本非常低，都是几年前的版本了，如果要编写btrace脚本，建议把安装目录下三个核心jar直接拷贝到工程中临时使用即可，如果想要随时使用，也可以将其上传到你们公司的maven私服上。</p><pre><code>[root@es1 btrace]# ll build/总用量 1572-rw-r--r--. 1 root root 460271 12月 16 00:44 btrace-agent.jar-rw-r--r--. 1 root root 358679 12月 16 00:44 btrace-boot.jar-rw-r--r--. 1 root root 785219 12月 16 00:44 btrace-client.jar</code></pre><p>（1）在使用btrace之前，我们先需要写一个简单的java程序，模拟成是线上正在跑的程序</p><p>代码比较简单，就是每隔随机的时间，随机生成两个整数，进行求和：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BtraceTest</span>  </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Random random=<span class="keyword">new</span> Random();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span>   </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=a+b;</span><br><span class="line">        System.out.println(<span class="string">"和："</span>+sum);</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                add(random.nextInt(<span class="number">10</span>), random.nextInt(<span class="number">10</span>));</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">10</span>) * <span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>     </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BtraceTest().run();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（2）主程序已经有了，下面就需要我们写btrace脚本，来监控”我们的线上程序了” 注意，需要在工程里面引入上面提到的3个jar。</p><p>监控的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> samples;</span><br><span class="line"><span class="keyword">import</span> com.sun.btrace.BTraceUtils;</span><br><span class="line"><span class="keyword">import</span> com.sun.btrace.annotations.*;</span><br><span class="line"><span class="keyword">import</span> com.sun.btrace.annotations.Export;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.sun.btrace.BTraceUtils.*;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@BTrace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnlineDebug</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnExit</span><span class="comment">//当成程序退出时，执行一些命令</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onexit</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        println(<span class="string">"BTrace program exits! with code: "</span> + code);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Export</span> <span class="comment">//可以用来统计调用次数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> counter;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnMethod</span>(clazz=<span class="string">"com.test.BtraceTest"</span>, method=<span class="string">"add"</span>,</span><br><span class="line">            location=<span class="meta">@Location</span>(value=Kind.RETURN))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">(@Self Object self, <span class="keyword">int</span> a,<span class="keyword">int</span> b,@Return <span class="keyword">int</span> result,@Duration <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        BTraceUtils.println(<span class="string">"参数： a: "</span>+a+<span class="string">"  b: "</span>+b);</span><br><span class="line">        BTraceUtils.println(<span class="string">"花费时间：  "</span>+time*<span class="number">1.0</span>/<span class="number">1000</span>+<span class="string">"ms"</span>);</span><br><span class="line">        jstack();<span class="comment">//打印堆栈信息</span></span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnEvent</span>(<span class="string">"1"</span>)<span class="comment">//通过事件触发，打印当前的程序调用次数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setL1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BTraceUtils.println(<span class="string">"executor count：  "</span>+counter);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//监控程序是否走到第22行代码</span></span><br><span class="line">    <span class="meta">@OnMethod</span>(clazz = <span class="string">"com.test.BtraceTest"</span>, location = <span class="meta">@Location</span>(value = Kind.LINE, line = <span class="number">22</span>))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onBind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        println(<span class="string">"执行到第22行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//每隔指定时间打印一下调用次数</span></span><br><span class="line">     <span class="meta">@OnTimer</span>(<span class="number">5000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BTraceUtils.println(<span class="string">"executor count：  "</span>+counter);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//    //慎用 监控程序里面是否调用了，java.lang下面的一些类或方法</span></span><br><span class="line"><span class="comment">//    @OnMethod(clazz="/java\\.lang\\..*/", method="/.*/")</span></span><br><span class="line"><span class="comment">//    public static void swingMethods( @ProbeClassName String probeClass, @ProbeMethodName String probeMethod) &#123;</span></span><br><span class="line"><span class="comment">//        print("entered " + probeClass + "."  + probeMethod);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（六）模拟测试</p><p>经过步骤五，我们已经准备好了模拟程序和监控脚本，下面来部署测试下：</p><p>（1）首先，通过maven将模拟程序打包成一个jar</p><p>（2）选择一台linux机器将jar包上传</p><p>（3）执行命令，启动模拟程序</p><p>java -cp  xxx.jar com.test.BtraceTest<br>linux终端输出内容如下：</p><p>和：8<br>和：11<br>和：3<br>和：12<br>和：14<br>和：15<br>和：8<br>和：2<br>和：8<br>和：7<br>和：18<br>和：4<br>（4）打开另一个linux终端部署监控脚本OnlineDebug.java到指定目录</p><p>赋予执行权限:<br><code>chmod +x OnlineDebug.java</code><br>执行jps命令，查看模拟程序的进程id</p><p>启动监控脚本：<br><code>btrace 2139 OnlineDebug.java</code><br>等待几秒后，控制台输出如下：</p><p>参数： a: 0  b: 8<br>花费时间：  101.973ms<br>com.test.BtraceTest.add(BtraceTest.java:11)<br>com.test.BtraceTest.run(BtraceTest.java:17)<br>com.test.BtraceTest.main(BtraceTest.java:28)<br>参数： a: 3  b: 4<br>花费时间：  116.611ms<br>com.test.BtraceTest.add(BtraceTest.java:11)<br>com.test.BtraceTest.run(BtraceTest.java:17)<br>com.test.BtraceTest.main(BtraceTest.java:28)<br>参数： a: 0  b: 2<br>花费时间：  113.168ms<br>com.test.BtraceTest.add(BtraceTest.java:11)<br>com.test.BtraceTest.run(BtraceTest.java:17)<br>com.test.BtraceTest.main(BtraceTest.java:28)<br>参数： a: 7  b: 7<br>花费时间：  113.434ms<br>com.test.BtraceTest.add(BtraceTest.java:11)<br>com.test.BtraceTest.run(BtraceTest.java:17)<br>com.test.BtraceTest.main(BtraceTest.java:28)<br>参数： a: 6  b: 1<br>花费时间：  181.184ms<br>com.test.BtraceTest.add(BtraceTest.java:11)<br>com.test.BtraceTest.run(BtraceTest.java:17)<br>com.test.BtraceTest.main(BtraceTest.java:28)<br>参数： a: 7  b: 6<br>花费时间：  190.881ms<br>com.test.BtraceTest.add(BtraceTest.java:11)<br>com.test.BtraceTest.run(BtraceTest.java:17)<br>com.test.BtraceTest.main(BtraceTest.java:28)<br>executor count：  44<br>可以看到监控脚本已经生效，成功获取到了模拟程序的内部参数，以及执行时间等。此刻另一个终端的模拟程序还在 正常运行，但内部其实已经被增强了。</p><p>如何退出监控脚本？</p><pre><code>非常简单，执行ctrl+c命令，选择1退出即可：</code></pre><p>参数： a: 9  b: 9<br>花费时间：  246.743ms<br>com.test.BtraceTest.add(BtraceTest.java:11)<br>com.test.BtraceTest.run(BtraceTest.java:17)<br>com.test.BtraceTest.main(BtraceTest.java:28)<br>参数： a: 3  b: 1<br>花费时间：  251.039ms<br>^CPlease enter your option:</p><pre><code>1. exit2. send an event3. send a named event4. flush console output</code></pre><p>1<br>总结：<br>    通过上面的例子，相信大家可以感受到btrace的强大，用其来排查正在运行的程序问题非常方便，感兴趣的朋友们可以自己试一试。</p><p>参考链接：<br>    <a href="https://github.com/btraceio/btrace/wiki/BTrace-Annotations" target="_blank" rel="noopener">https://github.com/btraceio/btrace/wiki/BTrace-Annotations</a><br>    <a href="https://yq.aliyun.com/articles/7569" target="_blank" rel="noopener">https://yq.aliyun.com/articles/7569</a><br>    <a href="https://www.jianshu.com/p/93e94b724476" target="_blank" rel="noopener">https://www.jianshu.com/p/93e94b724476</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java程序排查问题利器之Btrace&lt;/p&gt;
&lt;h4 id=&quot;（一）Btrace的介绍&quot;&gt;&lt;a href=&quot;#（一）Btrace的介绍&quot; class=&quot;headerlink&quot; title=&quot;（一）Btrace的介绍&quot;&gt;&lt;/a&gt;（一）Btrace的介绍&lt;/h4&gt;&lt;p&gt;BTr
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="btrace" scheme="http://yoursite.com/tags/btrace/"/>
    
  </entry>
  
  <entry>
    <title>tomcat 配置参数详解以及调优</title>
    <link href="http://yoursite.com/2018/09/24/tomcat-optimizing/"/>
    <id>http://yoursite.com/2018/09/24/tomcat-optimizing/</id>
    <published>2018-09-24T01:20:29.000Z</published>
    <updated>2018-09-24T02:35:23.569Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-tomcat加载机制"><a href="#一-tomcat加载机制" class="headerlink" title="一 tomcat加载机制"></a>一 tomcat加载机制</h3><pre><code>1 创建BootStrap 引导类加载器，加载JVM启动所需的类以及标准的扩展类2 创建System 系统类加载器，加载tomcat启动所需的类，通常是catalina_home/bin下3 创建web应用类加载器，加载应用WEB-INFO/class 其次在加载WEB-INFO/lib4 创建common类加载器，加载tomcat使用以及应用通用的一些类、如serverlet-api.jar</code></pre><h3 id="二-优化内核以及TCP连接"><a href="#二-优化内核以及TCP连接" class="headerlink" title="二 优化内核以及TCP连接"></a>二 优化内核以及TCP连接</h3><pre><code>fs.file-max = 655350　　# 系统文件描述符总量net.ipv4.ip_local_port_range = 1024 65535　　# 打开端口范围net.ipv4.tcp_max_tw_buckets = 2000　　# 设置tcp连接时TIME_WAIT个数net.ipv4.tcp_tw_recycle = 1　　# 开启快速tcp TIME_WAIT快速回收net.ipv4.tcp_tw_reuse = 1　　# 开启TIME_WAIT重用net.ipv4.tcp_syncookies = 1　　# 开启SYN cookies 当出现syn等待溢出，启用cookies来处理，可防范少量的syn攻击net.ipv4.tcp_syn_retries = 2　　# 对于一个新建的tcp连接，内核要发送几个SYN连接请求才决定放弃net.ipv4.tcp_synack_retries = 2　　# 这里是三次握手的第二次连接，服务器端发送syn+ack响应 这里决定内核发送次数net.ipv4.tcp_keepalive_time = 1200　　# tcp的长连接，这里注意：tcp的长连接与HTTP的长连接不同net.ipv4.tcp_fin_timeout = 15　　  # 设置保持在FIN_WAIT_2状态的时间net.ipv4.tcp_max_syn_backlog = 20000　　# tcp半连接最大限制数net.core.somaxconn = 65535　　# 定义一个监听最大的队列数net.core.netdev_max_backlog = 65535　　# 当网络接口比内核处理数据包速度快时，允许送到队列数据包的最大数目</code></pre><h3 id="三-Tomcat并发调优，Connector标签"><a href="#三-Tomcat并发调优，Connector标签" class="headerlink" title="三 Tomcat并发调优，Connector标签"></a>三 Tomcat并发调优，Connector标签</h3><pre><code>minProcessors：最小空闲连接线程数，用于提高系统处理性能，默认值为 10maxProcessors：最大连接线程数，即：并发处理的最大请求数，默认值为 75acceptCount：允许的最大连接数，应大于等于 maxProcessors ，默认值为 100enableLookups：是否反查域名，取值为： true 或 false 。为了提高处理能力，应设置为 falseconnectionTimeout：网络连接超时，单位：毫秒。设置为 0 表示永不超时，这样设置有隐患的。通常可设置为 30000 毫秒。其中和最大连接数相关的参数为maxProcessors 和 acceptCount 。如果要加大并发连接数，应同时加大这两个参数。web server允许的最大连接数还受制于操作系统的内核参数设置，通常 Windows 是 2000 个左右， Linux 是 1000 个左右。 maxThreads  客户请求最大线程数minSpareThreads    Tomcat初始化时创建的 socket 线程数maxSpareThreads   Tomcat连接器的最大空闲 socket 线程数enableLookups      若设为true, 则支持域名解析，可把 ip 地址解析为主机名redirectPort        在需要基于安全通道的场合，把客户请求转发到基于SSL 的 redirectPort 端口acceptAccount       监听端口队列最大数，满了之后客户请求会被拒绝（不能小于maxSpareThreads  ）connectionTimeout   连接超时minProcessors         服务器创建时的最小处理线程数maxProcessors        服务器同时最大处理线程数URIEncoding    URL统一编码</code></pre><h3 id="四-修改Tomcat-Connector运行模式"><a href="#四-修改Tomcat-Connector运行模式" class="headerlink" title="四 修改Tomcat Connector运行模式"></a>四 修改Tomcat Connector运行模式</h3><p>  Tomcat Connector有三种运行模式：</p><p>　　    bio：阻塞IO bio是三种运行模式中性能最低第一种。<br>　　    nio：是一个基于缓冲区，并能提供非阻塞I/O操作的JAVA API 因此NIO也成为非阻塞I/O，比bio拥有更好的并发性能。<br>　　    apr：调用httpd核心链接库来读取或文件传输，从而提高tomat对静态文件的处理性能。Tomcat APR模式也是Tomcat在高并发下的首选运行模式：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-tomcat加载机制&quot;&gt;&lt;a href=&quot;#一-tomcat加载机制&quot; class=&quot;headerlink&quot; title=&quot;一 tomcat加载机制&quot;&gt;&lt;/a&gt;一 tomcat加载机制&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1 创建BootStrap 引导类加载器，加
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="tomcat" scheme="http://yoursite.com/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>jvm 相关知识笔记</title>
    <link href="http://yoursite.com/2018/09/24/jvm/"/>
    <id>http://yoursite.com/2018/09/24/jvm/</id>
    <published>2018-09-24T01:19:56.000Z</published>
    <updated>2018-09-24T01:53:23.004Z</updated>
    
    <content type="html"><![CDATA[<p>ClassLoader:<br>    1 bootstrap classloader –java.lang,java.io<br>    2 extensions classloader<br>    3 System classloader  —-&gt;Tomcat<br>    4 Application classloader —&gt;alibaba,org.spring</p><p>Volatile:<br>    1 如果不声明volatile，变量装载到本地变量 中，或者cpu cache中，多线程下很容易导 致状态不⼀一致。<br>    2 声明了volatile，每次访问的都是主存中的数据，一致性能提升，但是还是不可靠的。<br>    3 volatile字段的访问效率很低，每次访问都需 要十几个nano。大约为lock的1/3时间</p><hr><h3 id="jvm-基础配置"><a href="#jvm-基础配置" class="headerlink" title="jvm 基础配置"></a>jvm 基础配置</h3><h5 id="堆设置"><a href="#堆设置" class="headerlink" title="堆设置"></a>堆设置</h5><pre><code>-Xms:初始堆大小-Xmx:最大堆大小-XX:NewSize=n:设置年轻代大小-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5-XX:MaxPermSize=n:设置持久代大小</code></pre><h5 id="收集器设置"><a href="#收集器设置" class="headerlink" title="收集器设置"></a>收集器设置</h5><pre><code>-XX:+UseSerialGC:设置串行收集器-XX:+UseParallelGC:设置并行收集器-XX:+UseParalledlOldGC:设置并行年老代收集器-XX:+UseConcMarkSweepGC:设置并发收集器</code></pre><h5 id="垃圾回收统计信息"><a href="#垃圾回收统计信息" class="headerlink" title="垃圾回收统计信息"></a>垃圾回收统计信息</h5><pre><code>-XX:+PrintGC-XX:+PrintGCDetails-XX:+PrintGCTimeStamps-Xloggc:filename</code></pre><h5 id="并行收集器设置"><a href="#并行收集器设置" class="headerlink" title="并行收集器设置"></a>并行收集器设置</h5><pre><code>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</code></pre><h5 id="并发收集器设置"><a href="#并发收集器设置" class="headerlink" title="并发收集器设置"></a>并发收集器设置</h5><pre><code> -XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ClassLoader:&lt;br&gt;    1 bootstrap classloader –java.lang,java.io&lt;br&gt;    2 extensions classloader&lt;br&gt;    3 System classloader  —-&amp;gt;Tomcat&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Mysql参数说明以及优化</title>
    <link href="http://yoursite.com/2018/09/24/mysql-tuning/"/>
    <id>http://yoursite.com/2018/09/24/mysql-tuning/</id>
    <published>2018-09-24T01:19:43.000Z</published>
    <updated>2018-09-24T05:04:55.690Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mysql参数说明以及调优"><a href="#Mysql参数说明以及调优" class="headerlink" title="Mysql参数说明以及调优"></a>Mysql参数说明以及调优</h3><ul><li><p>backlog：backlog值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。也就是说，如果MySql的连接数据达到maxconnections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即backlog，如果等待连接的数量超过back_log，将不被授予连接资源。可以从默认的50升至500</p></li><li><p>wait_timeout：数据库连接闲置时间，闲置连接会占用内存资源。可以从默认的8小时减到半小时</p></li><li><p>maxuserconnection: 最大连接数，默认为0无上限，最好设一个合理上限</p></li><li><p>thread_concurrency：并发线程数，设为CPU核数的两倍</p></li><li><p>skipnameresolve：禁止对外部连接进行DNS解析，消除DNS解析时间，但需要所有远程主机用IP访问</p></li><li><p>keybuffersize：索引块的缓存大小，增加会提升索引处理速度，对MyISAM表性能影响最大。对于内存4G左右，可设为256M或384M，通过查询 show status like’key_read%’，保证 key_reads/key_read_requests在0.1%以下最好</p></li><li><p>innodbbufferpool_size：缓存数据块和索引块，对InnoDB表性能影响最大。通过查询 show status like’Innodb_buffer_pool_read%’，保证 (Innodb_buffer_pool_read_requests–Innodb_buffer_pool_reads)/Innodb_buffer_pool_read_requests越高越好</p></li><li><p>innodbadditionalmempoolsize：InnoDB存储引擎用来存放数据字典信息以及一些内部数据结构的内存空间大小，当数据库对象非常多的时候，适当调整该参数的大小以确保所有数据都能存放在内存中提高访问效率，当过小的时候，MySQL会记录Warning信息到数据库的错误日志中，这时就需要该调整这个参数大小</p></li><li><p>innodblogbuffer_size：InnoDB存储引擎的事务日志所使用的缓冲区，一般来说不建议超过32MB</p></li><li><p>querycachesize：缓存MySQL中的ResultSet，也就是一条SQL语句执行的结果集，所以仅仅只能针对select语句。当某个表的数据有任何任何变化，都会导致所有引用了该表的select语句在Query Cache中的缓存数据失效。所以，当我们的数据变化非常频繁的情况下，使用Query Cache可能会得不偿失。根据命中率 (Qcache_hits/(Qcache_hits+Qcache_inserts)*100))进行调整，一般不建议太大，256MB可能已经差不多了，大型的配置型静态数据可适当调大. 可以通过命令 show status like’Qcache_%’查看目前系统Query catch使用大小</p></li><li><p>readbuffersize：MySql读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySql会为它分配一段内存缓冲区。如果对表的顺序扫描请求非常频繁，可以通过增加该变量值以及内存缓冲区大小提高其性能</p></li><li><p>sortbuffersize：MySql执行排序使用的缓冲大小。如果想要增加 ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。如果不能，可以尝试增加sortbuffersize变量的大小</p></li><li><p>readrndbuffer_size：MySql的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySql会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySql会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。</p></li><li><p>record_buffer：每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，可能想要增加该值</p></li><li><p>threadcachesize：保存当前没有与连接关联但是准备为后面新的连接服务的线程，可以快速响应连接的线程请求而无需创建新的</p></li><li><p>tablecache：类似于threadcache_size，但用来缓存表文件，对InnoDB效果不大，主要用于MyISAM</p></li></ul><h3 id="Mysql的一些优化建议"><a href="#Mysql的一些优化建议" class="headerlink" title="Mysql的一些优化建议"></a>Mysql的一些优化建议</h3><h5 id="一-慢sql优化步骤"><a href="#一-慢sql优化步骤" class="headerlink" title="一 慢sql优化步骤"></a>一 慢sql优化步骤</h5><p>1：开启慢查询日志，捕获慢sql</p><p>1)、查看慢查询日志是否开启</p><p><code>SHOW VARIABLES LIKE &#39;%slow_query_log%&#39;;</code></p><p>2）、开启慢查询日志</p><p><code>SET GLOBAL slow_query_log=1;</code></p><p>3)、查看慢日志阙值(这个值表示超过多长时间的SQL语句会被记录到慢查询日志中</p><p><code>SHOW [GLOBAL] VARIABLES LIKE &#39;%long_query_time%&#39;;</code></p><p>4)、设置慢sql阙值</p><p><code>SET GLOBAL long_query_time=3;</code></p><p>5)、查看有多少sql超过阙值</p><p><code>SHOW GLOBAL STATUS LIKE &#39;%Slow_queries%&#39;;</code><br>6)、使用mysqldownslow 命令（mysql安装的bin文件夹内）<br><img src="http://bmob-cdn-21665.b0.upaiyun.com/2018/09/24/bafef80f407ce083805d8a4929850737.png" alt="mysqldumpslow"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Mysql参数说明以及调优&quot;&gt;&lt;a href=&quot;#Mysql参数说明以及调优&quot; class=&quot;headerlink&quot; title=&quot;Mysql参数说明以及调优&quot;&gt;&lt;/a&gt;Mysql参数说明以及调优&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;backlog：backlog值指
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>redis配置详解以及参数调优</title>
    <link href="http://yoursite.com/2018/09/24/redis-optimizing/"/>
    <id>http://yoursite.com/2018/09/24/redis-optimizing/</id>
    <published>2018-09-24T01:19:25.000Z</published>
    <updated>2018-09-24T01:26:49.254Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 相关配置说明<br>maxmemory-policy:</p><h1 id="volatile-lru-gt-remove-the-key-with-an-expire-set-using-an-LRU-algorithm"><a href="#volatile-lru-gt-remove-the-key-with-an-expire-set-using-an-LRU-algorithm" class="headerlink" title="volatile-lru -&gt; remove the key with an expire set using an LRU algorithm"></a>volatile-lru -&gt; remove the key with an expire set using an LRU algorithm</h1><p>内存不足时，在设置过期时间的键空间内，移除最近最少使用的key</p><h1 id="allkeys-lru-gt-remove-any-key-according-to-the-LRU-algorithm"><a href="#allkeys-lru-gt-remove-any-key-according-to-the-LRU-algorithm" class="headerlink" title="allkeys-lru -&gt; remove any key according to the LRU algorithm"></a>allkeys-lru -&gt; remove any key according to the LRU algorithm</h1><p>当内存不足时，移除最近最少使用的key</p><h1 id="volatile-random-gt-remove-a-random-key-with-an-expire-set"><a href="#volatile-random-gt-remove-a-random-key-with-an-expire-set" class="headerlink" title="volatile-random -&gt; remove a random key with an expire set"></a>volatile-random -&gt; remove a random key with an expire set</h1><p>内存不足时，在设置过期时间的键控件，随机移除</p><h1 id="allkeys-random-gt-remove-a-random-key-any-key"><a href="#allkeys-random-gt-remove-a-random-key-any-key" class="headerlink" title="allkeys-random -&gt; remove a random key, any key"></a>allkeys-random -&gt; remove a random key, any key</h1><p>内存不足是，随机移除</p><h1 id="volatile-ttl-gt-remove-the-key-with-the-nearest-expire-time-minor-TTL"><a href="#volatile-ttl-gt-remove-the-key-with-the-nearest-expire-time-minor-TTL" class="headerlink" title="volatile-ttl -&gt; remove the key with the nearest expire time (minor TTL)"></a>volatile-ttl -&gt; remove the key with the nearest expire time (minor TTL)</h1><p>设置更早过期时间的key有限移除（或者是快过期的key）</p><h1 id="noeviction-gt-don’t-expire-at-all-just-return-an-error-on-write-operations"><a href="#noeviction-gt-don’t-expire-at-all-just-return-an-error-on-write-operations" class="headerlink" title="noeviction -&gt; don’t expire at all, just return an error on write operations"></a>noeviction -&gt; don’t expire at all, just return an error on write operations</h1><p>当内存不足时以容纳新写入的数据时，新写入操作就会抛出异常</p><p>##缓存穿透：<br>    黑客估计查询缓存中不存在的数据，导致所有的请求都去数据库查询，从而使数据库连接异常。<br>    解决方案：<br>        1 利用互斥锁，缓存失效时，获取锁，待数据取回，更新至缓存，释放锁。没得到锁的，等待。（互斥锁、悲观锁、乐观锁）</p><pre><code>2 异步更新，监听缓存失效状态，通知后台更新缓存的策略。（需预加载数据）3 提供一个有效的拦截机制,如布隆过滤器。</code></pre><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><pre><code>换从同一时间大面积失效，导致大量请求数据库，使得数据库连接异常解决方案：    1 定一个缓存失效时间，在加上一个随机值，避免集体失效    2 使用互斥锁，但会影响吞吐量    3 双缓存，错开失效时间</code></pre><p>问题： 1 互斥锁 、多线程安全等如何实施？<br>      2 redis集群的存储策略？<br>      3 redis.conf 配置参数的意义？<br>      4 redis存储类型以及使用场景？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis 相关配置说明&lt;br&gt;maxmemory-policy:&lt;/p&gt;
&lt;h1 id=&quot;volatile-lru-gt-remove-the-key-with-an-expire-set-using-an-LRU-algorithm&quot;&gt;&lt;a href=&quot;#volatil
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>从技术走向管理-lesson-One</title>
    <link href="http://yoursite.com/2018/09/23/pm-learing-lesson-one/"/>
    <id>http://yoursite.com/2018/09/23/pm-learing-lesson-one/</id>
    <published>2018-09-23T13:50:43.000Z</published>
    <updated>2018-09-24T02:35:46.157Z</updated>
    
    <content type="html"><![CDATA[<h4 id="管理转型："><a href="#管理转型：" class="headerlink" title="管理转型："></a>管理转型：</h4><pre><code>1 让计划成为习惯，计划性，任何事需要有计划的实施。如面试，招聘，项目承接等2 做任何事之前，要明确做什么，做到什么程度，以及为什么做。3 思维转变，做应该做的事，而不是做喜欢做的事。4 树立威信，威：身先士卒，起好带头作用。信：说道做到。5 与团队之间建立信任，坚持用人不疑。7 向上反馈项目组的成绩和辛苦，向下结合项目组情况，分解传达公司领导层的方案</code></pre><hr><h5 id="有效分派任务："><a href="#有效分派任务：" class="headerlink" title="有效分派任务："></a>有效分派任务：</h5><pre><code>1 因人派事：让每个人尽量干最适合他的工作。2 和下属沟通工作内容，工作意义，工作时限以及合格标准时，一定要让下属复述，不要简单咨询是否清楚的问题。3一定要让下属明确自己的权利范围和责任，避免反授权或过多请示。4不要只给任务，却不给必须的培养5 不要放羊6 无论是奖励还是处罚，都一定要新手承诺</code></pre><hr><h4 id="监督比激励重要："><a href="#监督比激励重要：" class="headerlink" title="监督比激励重要："></a>监督比激励重要：</h4><pre><code>项目过程中适当的监督，重点激励和表扬，辅助必要的批评和惩罚</code></pre><hr><h5 id="授权："><a href="#授权：" class="headerlink" title="授权："></a>授权：</h5><pre><code>1 通过授权可以让管理者不被一些琐事羁绊，进而解放时间，把精力放到更有价值的工作上去从而提高管理者的工作效率2 通过授权，能够激励员工，进而提高员工的工作效率。并且能培养下属的能力** 工作的授权一定要做到合理和正确的授权。授权前，需要与下属明确要承担的责任。首先：授权不受责，需要勇于承担管理责任，对外承担由下属所犯的错误，对内，要按照约定对下属的错误进行必要的批评和惩罚其次：在授权的过程中一定要监督和检查。千万不要做甩手掌柜。但是如何监督才能避免下属的反感，（注意：过多的监督或者干涉，可能会使得下属觉得又要让我做事，又不信任我。）</code></pre><hr><h5 id="马洛斯需求理论："><a href="#马洛斯需求理论：" class="headerlink" title="马洛斯需求理论："></a>马洛斯需求理论：</h5><pre><code>生理需求，安全需求、归属和爱的需求、尊重的需求、自我实现的需求</code></pre><hr><h5 id="鞭打快牛的弊端（任务分派）"><a href="#鞭打快牛的弊端（任务分派）" class="headerlink" title="鞭打快牛的弊端（任务分派）"></a>鞭打快牛的弊端（任务分派）</h5><pre><code>快牛：对于团队中能力强，做事认真负责，雷雨风险的员工弊端：快牛变慢牛，最终快牛会离职。解决方案：1 建立严格、客观、公正的绩效考核制度。        2 施行科学，合理的竞争和淘汰机制。</code></pre><hr><h5 id="习惯培养："><a href="#习惯培养：" class="headerlink" title="习惯培养："></a>习惯培养：</h5><pre><code>过程：被动-&gt;主动-&gt;自动要点：1：提高认识，让对方充分认识到好习惯对自己的意义和价值2：明确改习惯锁对应的行为规范，让对方清楚该良好习惯的具体标准。有了标准，对方才知道如何操作3：梳理可供效仿的榜样，这个榜样可以让对方自己寻找，榜样可以作为对方努力的灯塔，学习的参照对象，要让对方自己与其榜样对比，但是切勿在对方面前拿对方和其榜样做对比。4：迟滞以恒的行为训练，一般来说二十一天可以初步形成习惯，九十天持续的训练能形成比较稳定的习惯。5：及时评估和有效的奖惩，以激励和奖励为主导，体现上司对下属的关心重视，并持续提供下属养成某一良好习惯所需要的外在推动力。6：营造良好的团队环境和氛围，从而为下属持续呈现着已良好的性能习惯提供“土壤”。</code></pre><hr><h5 id="处理员工工作偏差："><a href="#处理员工工作偏差：" class="headerlink" title="处理员工工作偏差："></a>处理员工工作偏差：</h5><pre><code>1 做好处理前的准备工作，处理好自己的心情，不要带着负面情绪去处理员工的工作偏差2 确认问题及导致问题产生的真正原因。3 提出并确定改进方案4 确认员工如何改进5 检查和跟踪改进结果</code></pre><p>绩效考核：<br>    OKR<br>    1 经理和员工设置的期望（期望值是否需要经过正式沟通双方达成一致）<br>    2 项目组，部门，以及总部的目标需要下达至所有员工（促使每个人融入团队以及部门的目标，并为之奋斗）<br>    3 对于团队的贡献<br>    4 与同级比较，突破项目组以及部门局限<br>    5 员工本级别自身的期望<br>    6 个人发展计划和规划</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;管理转型：&quot;&gt;&lt;a href=&quot;#管理转型：&quot; class=&quot;headerlink&quot; title=&quot;管理转型：&quot;&gt;&lt;/a&gt;管理转型：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1 让计划成为习惯，计划性，任何事需要有计划的实施。如面试，招聘，项目承接等
2 做任何事之前，要明
      
    
    </summary>
    
      <category term="项目管理" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="项目管理" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
      <category term="PM" scheme="http://yoursite.com/tags/PM/"/>
    
  </entry>
  
  <entry>
    <title>通过jdk生成webservice接口源码</title>
    <link href="http://yoursite.com/2018/09/23/java-wsdl/"/>
    <id>http://yoursite.com/2018/09/23/java-wsdl/</id>
    <published>2018-09-23T13:04:54.000Z</published>
    <updated>2018-09-23T13:09:56.167Z</updated>
    
    <content type="html"><![CDATA[<p>通过JDK中wsimport命令生成webservice接口源码</p><p>wsimport -encoding utf-8 -keep -d D:\class -s D:\java\ -p packageName -verbose http:\xxxxxxx?wsdl</p><p>-encoding 编码格式<br>-d 指定class文件存储路径<br>-s 指定java文件存储路径<br>-p 客户端包名<br>-verbose 控制台输出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过JDK中wsimport命令生成webservice接口源码&lt;/p&gt;
&lt;p&gt;wsimport -encoding utf-8 -keep -d D:\class -s D:\java\ -p packageName -verbose http:\xxxxxxx?wsdl
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="wsdl" scheme="http://yoursite.com/tags/wsdl/"/>
    
  </entry>
  
  <entry>
    <title>java之序列化（serializable，Externalizable）</title>
    <link href="http://yoursite.com/2018/09/23/java-serialize/"/>
    <id>http://yoursite.com/2018/09/23/java-serialize/</id>
    <published>2018-09-23T13:03:12.000Z</published>
    <updated>2018-09-23T13:06:55.782Z</updated>
    
    <content type="html"><![CDATA[<p>Serializable – interface</p><p>Externalizable 实现Serializable 的abstract Class</p><p>Parcable Android序列化的另一种操作模式 与Externalizable方式相似</p><p>某些时候我们在序列化时，只希望序列化部分属性，若使用serializable，则对象的所有私有非私有属性都将会序列化，那此时若某个属性不需要序列化时，则需要加上transient 关键字修饰。则该字段不会被序列化，<br>当然使用externalizabel 或者Android Parcable序列化时，需要重写序列化的读写操作，如果不希望该字段序列化，则在重写时，取消该字段的读写操作即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Serializable – interface&lt;/p&gt;
&lt;p&gt;Externalizable 实现Serializable 的abstract Class&lt;/p&gt;
&lt;p&gt;Parcable Android序列化的另一种操作模式 与Externalizable方式相似&lt;/p&gt;

      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="serialize" scheme="http://yoursite.com/tags/serialize/"/>
    
  </entry>
  
  <entry>
    <title>java之Aop</title>
    <link href="http://yoursite.com/2018/09/23/java-aop/"/>
    <id>http://yoursite.com/2018/09/23/java-aop/</id>
    <published>2018-09-23T12:59:49.000Z</published>
    <updated>2018-09-23T13:06:22.291Z</updated>
    
    <content type="html"><![CDATA[<p> Aop 知识点</p><p> 1 jdk 动态代理<br> 2 CGLIB 动态代理</p><p> 区别：<br> 1 jdk 所有目标类需实现一个接口<br> 2 jdk 需要实现动态代理类，实现InvocationHandler接口 并实现invoke方法<br> 3 cglib 不需要实现接口<br> 4 cglib 代理类需实现MethodInterceptor,并实现其intercpter方法<br> 5 cglib 实现增强的目标类工厂Factory,使用Enhancer类的方法获取增强后的目标类<br> 6 cglib 关联cglib.jar和asm.jar(asm生成目标类执行效率较高)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; Aop 知识点&lt;/p&gt;
&lt;p&gt; 1 jdk 动态代理&lt;br&gt; 2 CGLIB 动态代理&lt;/p&gt;
&lt;p&gt; 区别：&lt;br&gt; 1 jdk 所有目标类需实现一个接口&lt;br&gt; 2 jdk 需要实现动态代理类，实现InvocationHandler接口 并实现invoke方法&lt;br&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="aop" scheme="http://yoursite.com/tags/aop/"/>
    
  </entry>
  
  <entry>
    <title>linux 服务器命令</title>
    <link href="http://yoursite.com/2018/09/23/linux-cmd/"/>
    <id>http://yoursite.com/2018/09/23/linux-cmd/</id>
    <published>2018-09-23T12:51:02.000Z</published>
    <updated>2018-09-24T01:54:07.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务器句柄数相关命令"><a href="#服务器句柄数相关命令" class="headerlink" title="服务器句柄数相关命令"></a>服务器句柄数相关命令</h2><h4 id="1-查看当前用户的文件句柄限制"><a href="#1-查看当前用户的文件句柄限制" class="headerlink" title="1. 查看当前用户的文件句柄限制"></a>1. 查看当前用户的文件句柄限制</h4><p>`<br>ulimit -a </p><h2 id=""><a href="#" class="headerlink" title="`"></a>`</h2><h4 id="2-用户级别的句柄数限制修改。"><a href="#2-用户级别的句柄数限制修改。" class="headerlink" title="2. 用户级别的句柄数限制修改。"></a>2. 用户级别的句柄数限制修改。</h4><p>修改 /etc/security/limits.conf 增加下面的代码：<br>用户名(或者用*表示所有用户)  soft nofile 65535<br>用户名 hard nofile 65535<br>有两种限制，一种是soft软限制，在数目超过软限制的时候系统会给出warning警告，但是达到hard硬限制的时候系统将拒绝或者异常了。</p><h2 id="修改之后可能需要重启shell生效。"><a href="#修改之后可能需要重启shell生效。" class="headerlink" title="修改之后可能需要重启shell生效。"></a>修改之后可能需要重启shell生效。</h2><h4 id="3-系统级别的句柄数限制修改。"><a href="#3-系统级别的句柄数限制修改。" class="headerlink" title="3. 系统级别的句柄数限制修改。"></a>3. 系统级别的句柄数限制修改。</h4><p><code>sysctl -w fs.file-max 65536</code><br>或<br><code>echo &quot;65536&quot; &gt; /proc/sys/fs/file-max</code><br>两者作用是相同的，前者改内核参数，后者直接作用于内核参数在虚拟文件系统（procfs, psuedo file system）上对应的文件而已。<br>可以用下面的命令查看新的限制<br><code>sysctl -a | grep fs.file-max</code><br>或者<br><code>cat /proc/sys/fs/file-max</code><br>修改内核参数<br>(<code>)/etc/sysctl.confecho &quot;fs.file-max=65536&quot; &gt;&gt; /etc/sysctl.confsysctl -p(</code>)</p><ul><li>查看系统总限制，命令：<br><code>cat /proc/sys/fs/file-max</code></li><li>查看整个系统目前使用的文件句柄数量，命令：<br><code>cat /proc/sys/fs/file-nr</code></li><li>查看某个进程开了哪些句柄<br><code>lsof -p pid</code></li><li>某个进程开了几个句柄<br><code>lsof -p pid |wc -l</code></li><li>也可以看到某个目录 /文件被什么进程占用了,显示已打开该目录或文件的所有进程信息<br><code>lsof path/filename</code></li></ul><hr><h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><ul><li>查找进程<br><code>for i in &#39;pgrep java&#39;;do echo $i; ll /proc/$i/cwd; netstat -ntlp|grep $i;done</code></li><li>tomcat并发数<br><code>ps -ef|grep httpd|wc -l</code></li><li>外部访问量的ip地址<br><code>grep ip:port | awk&#39;{print $5}&#39;| awk -F:&#39;{print ($1&gt;$4?$1:$4)}&#39;|sort|uniq -c |sort -nr|head</code></li><li>开放hosts文件的读写权限<br><code>sudo /bin/chmod +a &#39;user:apple:allow write&#39; /etc/hosts</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;服务器句柄数相关命令&quot;&gt;&lt;a href=&quot;#服务器句柄数相关命令&quot; class=&quot;headerlink&quot; title=&quot;服务器句柄数相关命令&quot;&gt;&lt;/a&gt;服务器句柄数相关命令&lt;/h2&gt;&lt;h4 id=&quot;1-查看当前用户的文件句柄限制&quot;&gt;&lt;a href=&quot;#1-查看当前
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Android之Activity四种加载模式</title>
    <link href="http://yoursite.com/2018/09/23/lunchMode/"/>
    <id>http://yoursite.com/2018/09/23/lunchMode/</id>
    <published>2018-09-23T05:12:32.000Z</published>
    <updated>2018-09-25T09:33:34.705Z</updated>
    
    <content type="html"><![CDATA[<p>本章主要对Android的Activity 四种加载模式lunchMode与Inteng Flag进行讲解和说明</p><p>activity一共有四种加载模式：standerd,singleTop,singleTask,singleInstance。下面就对这四种加载模式进行说明</p><h5 id="standerd"><a href="#standerd" class="headerlink" title="standerd"></a>standerd</h5><p>系统默认的启动标准模式。<br>作用：每新打开一个activity，都会生成一个新的activity实例，并放于栈顶；<br><img src="/Users/apple/Pictures/博客截图/diagram_backstack.png" alt="diagram_backstack"></p><h5 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h5><ul><li>如果当前任务的顶部已存在 Activity 的一个实例，则系统会通过调用该实例的 onNewIntent() 方法向其传送 Intent，而不是创建 Activity 的新实例.</li><li>Activity 可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例.</li></ul><h5 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h5><ul><li>系统创建新任务并实例化位于新任务底部的 Activity. 但是，如果该 Activity 的一个实例已存在于一个单独的任务中，则系统会通过调用现有实例的 onNewIntent() 方法向其传送 Intent，而不是创建新实例.</li><li>一次只能存在 Activity 的一个实例.</li></ul><h5 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h5><ul><li>与 “singleTask” 相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中.</li><li>该 Activity 始终是其任务唯一仅有的成员；由此 Activity 启动的任何 Activity 均在单独的任务中打开.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本章主要对Android的Activity 四种加载模式lunchMode与Inteng Flag进行讲解和说明&lt;/p&gt;
&lt;p&gt;activity一共有四种加载模式：standerd,singleTop,singleTask,singleInstance。下面就对这四种加载模
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
</feed>
